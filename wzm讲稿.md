# 讲稿

大家好, 刚刚郭鸿宇同学给大家介绍了目录式协议, 接下来由我来给大家介绍一下**基于目录式协议的性能优化方案**, 即通过预测来加速一致性协议. 



### 第一张PPT

Cosmos预测器是两级适应性预测器, 第一级体现在 **历史消息表** (MHT) 上, 该表会记录每一个缓存块的历史消息. 其以缓存块地址为索引, 表项则由 **历史消息寄存器** (MHR) 构成, MHR项 中记录该数据块 **最近一段时间内** 所收到的一致性消息序列. 而MHR中记录的历史消息数量, 称为 MHR 的深度. 

Cosmos预测器的第二级则是 **模式匹配表** (PHT),  PHT表记录了所接收到的一致性消息序列的规律. 其以MHR项为索引, 表项则是记录可能跟在该消息序列后的下一条消息.

而要通过Cosmos预测器进行预测, 首先需要以缓存块地址为索引查找MHT表中的表项MHR, 再以该MHR项为索引检索 PHT 表, 即可得到对应的预测项. 

基于目录的一致性协议中, 接收一致性消息的主体分别有Cache和目录, 在硬件实现中, 目录和每个Cache都应设有Cosmos预测器. 



### 第二张PPT

Cosmos的预测原理比较简单直接, 其实就是根据每个Cache块在最近一段时间内所收到的消息 来预测下一条可能接收到的消息. 下面我们来分析一下Cosmos预测器的可靠性. 

首先第一点就是上述提到的 MHR 的深度. 一般情况下, MHR项记录更多的历史消息,  会更有利于Cosmos更好地识别当前共享模式下一致性消息的规律性, 将其记录在 PHT 表中, 并基于该规律来做出更精准的预测. 

并且有研究表明, 一个经过细致调优的并行程序中, 一个数据块被共享的平均核数量不超过两个. 也就是说, 对于每个Cache模块而言, 其接收的消息来源有限, 故而并不需要在Cosmos中设置过高的 MHR 深度. 本篇论文中所实践的五个并行程序来说, MHR 深度取3就已完全足够. 

第二点则是, 与分支预测器类似的是, Cosmos通过需要识别出噪音并将其过滤掉. 比如在绝大多数情况消息B总是跟着消息A, 但偶尔会出现消息A后面跟着的是消息C, Cosmos并不会仅仅根据这一次偶发情况而对普遍情况下的消息模式进行更改. 而这**则基于Cosmos的Filter机制, 即对同一个Cache数据块而言, 只有连续遇到N次预测失败的情况, 才会在PHT表中对预测结果进行更新**. 实现机制则是在PHT表中设置Counter位, 只有在Counter为1时才在PHT表中做相应更新. 



### 第三张PPT

既然是预测, 那必然会有预测失败的情况. 如果Cosmos预测失败, 所做出的响应很有可能会使缓存块, 甚至是处理器的状态不一致, 进而导致程序的执行错误. 

论文中所提到的处理措施, 是根据响应动作的影响程度进行分类, 并对各类响应采取不同代价的恢复策略. 

- 首先是影响最小的, 即虽然更改了缓存块状态, 但并不会影响程序正确执行. 
  - 对于该类动作, 可直接采取鸵鸟策略. 

- 其次是更改了缓存块状态, 但并未更改处理器状态的动作. 
  - 对于该类动作, 由于处理器对于缓存块状态的改变完全透明, 故而可以直接在Cache中抛弃现有错误状态, 恢复到原有状态即可. 
- 最后是影响最严重的响应动作, 即不仅会改变缓存块状态, 并且还导致处理器状态改变. 
  - 只能通过在预测前保存二者状态, 并且在预测失败时回滚至上一个保存点.  

> 比如缓存数据块的换出动作, 有可能使其从Exclusive(独占)状态变为InValid(无效)状态, 而这一操作所带来的结果即是可能会导致下一条读块的请求引发缓存缺失, 即这只会影响性能, 并不会影响正确性. 

